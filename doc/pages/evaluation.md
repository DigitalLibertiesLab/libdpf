<!-- # Evaluating DPFs {#evalaution} -->
Once a `DPF` generated, the *eval_* * functions are used to evaluate differents inputs. 
The appropriate function depends on your specific needs. If you only need the DPF's output 
for a single input value, use `eval_point`. For evaluating a continuous range of inputs, 
`eval_interval` is suitable. To analyze the DPF's behavior across its entire domain, use `eval_full`. 
The code likely offers different implementations of memoization and output buffers, allowing you to 
optimize for memory usage or execution speed depending on your needs.\n
Using a PRG while making a `DPF` allows the user to check how much it cost to manipulate the `DPF`s.

# Memoizers
The `memoizers` remembers the most used path while the DPF is being created. These are usefull functions 
to improve the speed and the cost of execution.

**Code samples**\n
For instance, in the code below the utilization of `dpf::make_basic_path_memoizer` reduced by 10 the time of execution 
compare to the code that is commented that doesn't use the `memoizers`. 
<div class="tabbed">

  - <b class="tab-title">memoizers.cpp</b>  \include{cpp} evaluation/memoizers.cpp

</div>


# dpf::eval_point
This function evaluate a single input of a DPF. The XOR result of the `eval_point` for both shares will only be equal to 1 if it represents the correct input in both evaluations. As input arguments it uses the `share` and the input to evaluate (note: it can't be a wildcard, otherwise it will throw an error).\n

**See also**\n
PIR

**Pro tip**\n
Use the `dpf::pathmemoizer` for a faster execution.\n

**Code samples**\n
<div class="tabbed">

  - <b class="tab-title">eval_point.cpp</b>  \include{cpp} evaluation/eval_point.cpp

</div>

# dpf::eval_interval
This function evaluates a contiguous range of inputs. As input arguments it uses the `share` generated by `make_dpf`, 
`from` and `to` for the range of inputs to evaluate.\n

**See also**\n
PIR

**Code samples**\n
<div class="tabbed">

  - <b class="tab-title">eval_interval.cpp</b>  \include{cpp} evaluation/eval_interval.cpp

</div>

# dpf::eval_full
This function evaluate all the passible inputs it only uses as argument the `share` of the `DPF` to evaluate.

**Code samples**\n
<div class="tabbed">

  - <b class="tab-title">eval_full.cpp</b>  \include{cpp} evaluation/eval_full.cpp

</div>


# dpf::eval_sequence
This function evaluate a subset of inputs that is not contiguous (useful for a `DPF` made with `keyword`), 
it uses as arguments the `share` generated by `make_dpf`, `from` and `to` for the subset of inputs to evaluate.\n
For a better utilization, you can use the `make_sequence_recipe` it takes as input a sorted list and returns a `recipe`. 
The cost of creating is a little bit worse than just calling `eval_sequence`, however once the `recipe` created 
`eval_sequence` is faster and has a better cost.


**Code samples**\n
<div class="tabbed">

  - <b class="tab-title">eval_sequence.cpp</b>  \include{cpp} evaluation/eval_sequence.cpp

</div>

# Output buffers